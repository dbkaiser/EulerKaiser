package com.dbk.puzzle;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

/**
 * How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
 * 
 * @author edogboo
 *
 * the following solution is stupid, use double as the number count. and use set to store, then count size.
 */
public class Puzzle29 {
	
	public static int bound = 100;
	public static boolean[][] board = new boolean[bound+1][bound+1];
	// factors will store all the factors of current number
	public static Map<Integer, int[]> factors = new HashMap<Integer, int[]>();
	
	public static void main(String args[]){
		for(int i = 2; i< board.length; i++){
			for(int j = 2; j< board[0].length; j++){
				board[i][j] = true;
			}
		}
		for(int i = 2 ; i < board[0].length; i++){
			factors.put(i, findFactors(i));
		}
		
		//counting remove condition of a^b = a^xt, where a,b,x,t are all integers;
		int count = (bound-1)*(bound-1);
		for(int a = 2; a <= Math.sqrt((double)board.length) + 1; a++){
			for(int b = 2; b < board[0].length; b++){
				int[] facts = factors.get(b);
				if(facts == null) continue;
				if(!board[a][b]) continue;
				for(int i: facts){
					int big = pow(a,i);
					if(big > bound) continue;
					if(big < 0) {
						continue;
					}
					if(board[(int)big][b/i]){count--; board[(int) big][b/i] = false;}
				}
			}
		}
		
		//counting , still left condition of a^b = c^d, where a= x^y, c = x^z, thus y*b = z*d;
		// this condition will include 2^2 2^3 and 3^2 3^3, etc.
		int base = 2;
		count = minusCross(base, count,2,3);
		count = minusCross(base, count,2,5);
		count = minusCross(base, count,3,5);
		count = minusCross(base, count,5,6);
		count = minusCross(base, count,4,5);
		count = minusCross(base, count,3,4);
		count = minusCross(base, count,4,6);
		base = 3;
		count = minusCross(base, count,2,3);
		count = minusCross(base, count,3,4);
		base = 4;
		count = minusCross(base, count,2,3);
		print();
		System.out.println(count);
		
	}
	
	/**
	 * 
	 * @param base
	 * @return count
	 */
	public static int minusCross(int base, int count, int time1, int time2){
		int sqr=1,cub = 1;
		for(int i = 0; i < time1; i++){
			sqr *= base;
		}
		for(int i = 0; i< time2; i++){
			cub *= base;
		}
		int boarder = bound/ ((time1>time2)?time1:time2);
		for(int i = 1;i <= boarder; i++){
			
			if(!board[sqr][time2*i] || !board[cub][time1*i]) continue;
			board[cub][time1*i] = false;
			count--;
		}
		return count;
	}
	
	//b times a
	public static int pow(int a, int b){
		int i = a;
		for(int j = 1 ; j< b; j ++){
			i *= a;
		}
		return i;
	}
	
	public static void print(){
		int innerCount =0;
		for(int i = 1; i <= bound; i++){
			System.out.print(i + "\t");
		}
		System.out.println();
		for(int i = 2; i<= bound; i++){
			System.out.print(i + "\t");
			int lineCount = 0;
			for(int j = 2; j<= bound; j++){
				System.out.print(board[i][j]+"\t");
				if(board[i][j]) {innerCount++;
					lineCount++;
				}
				
			}
			System.out.print(lineCount);
			System.out.println();
			
		}
		System.out.println(innerCount);
		System.out.println();
	}
	/**
	 * find all factors of the number
	 * @param number integer from 2 to 100;
	 * @return list of factors
	 */
	public static int[] findFactors(int number){
		List<Integer> list = new LinkedList<Integer>();
		for(int i = 2; i<= number/2 ; i++){
			if(number % i ==0)
				list.add(i);
		}
		if(list.size() == 0 ) return null;
		int result[] = new int[list.size()];
		for(int i =0 ;i < list.size(); i++){
			result[i] = list.get(i);
		}
		return result;
	}
}
